package io.github.MoWei.Frozen;import android.annotation.SuppressLint;import android.app.AlertDialog;import android.app.Dialog;import android.content.ContentResolver;import android.content.Context;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.Matrix;import android.net.Uri;import android.os.FileUtils;import android.provider.OpenableColumns;import android.util.Log;import android.widget.ImageView;import androidx.annotation.DrawableRes;import androidx.annotation.LayoutRes;import androidx.annotation.NonNull;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.InetSocketAddress;import java.net.Socket;import java.net.URL;import java.util.Objects;import java.util.Set;public class Utils {    public static byte[] getNetworkData(String link) {        try {            URL url = new URL(link);            HttpURLConnection conn = (HttpURLConnection) url.openConnection();            conn.setConnectTimeout(5 * 1000);            conn.setRequestMethod("GET");            conn.connect();            if (conn.getResponseCode() != 200) return null;            InputStream is = conn.getInputStream();            ByteArrayOutputStream os = new ByteArrayOutputStream();            int len;            byte[] buffer = new byte[4096];            while ((len = is.read(buffer)) != -1)                os.write(buffer, 0, len);            is.close();            os.close();            return os.toByteArray();        } catch (IOException e) {            return null;        }    }        // 小端 只是避免内存越界，不处理转换失败的情况    public static int Byte2Int(byte[] bytes, int byteOffset) {        if (bytes == null || (byteOffset + 4) > bytes.length)            return 0;        return Byte.toUnsignedInt(bytes[byteOffset]) |                (Byte.toUnsignedInt(bytes[byteOffset + 1]) << 8) |                (Byte.toUnsignedInt(bytes[byteOffset + 2]) << 16) |                (Byte.toUnsignedInt(bytes[byteOffset + 3]) << 24);    }    public static void Int2Byte(int value, byte[] bytes, int byteOffset) {        if (bytes == null) return;        if ((byteOffset + 4) > bytes.length) {            while (byteOffset < bytes.length)                bytes[byteOffset++] = 0;            return;        }        bytes[byteOffset++] = (byte) value;        bytes[byteOffset++] = (byte) (value >> 8);        bytes[byteOffset++] = (byte) (value >> 16);        bytes[byteOffset] = (byte) (value >> 24);    }    public static void Byte2Int(byte[] bytes, int byteOffset, int byteLength, int[] ints, int intOffset) {        if (ints == null || bytes == null || (intOffset + byteLength / 4) > ints.length ||                (byteOffset + byteLength) > bytes.length)            return;        for (int byteIdx = byteOffset; byteIdx < byteOffset + byteLength; byteIdx += 4) {            ints[intOffset++] = Byte.toUnsignedInt(bytes[byteIdx]) |                    (Byte.toUnsignedInt(bytes[byteIdx + 1]) << 8) |                    (Byte.toUnsignedInt(bytes[byteIdx + 2]) << 16) |                    (Byte.toUnsignedInt(bytes[byteIdx + 3]) << 24);        }    }    public static void Int2Byte(int[] ints, int intOffset, int intLength, byte[] bytes, int byteOffset) {        if (ints == null || bytes == null || (intOffset + intLength) > ints.length ||                (byteOffset + intLength * 4) > bytes.length)            return;        for (int intIdx = intOffset; intIdx < intOffset + intLength; intIdx++) {            bytes[byteOffset++] = (byte) ints[intIdx];            bytes[byteOffset++] = (byte) (ints[intIdx] >> 8);            bytes[byteOffset++] = (byte) (ints[intIdx] >> 16);            bytes[byteOffset++] = (byte) (ints[intIdx] >> 24);        }    }    public static String getFileAbsolutePath(@NonNull Context context, @NonNull Uri uri) {        File file = null;        //android10以上转换        if (Objects.equals(uri.getScheme(), ContentResolver.SCHEME_FILE)) {            file = new File(uri.getPath());        } else if (uri.getScheme().equals(ContentResolver.SCHEME_CONTENT)) {            //把文件复制到沙盒目录            ContentResolver contentResolver = context.getContentResolver();            @SuppressLint("Recycle")            Cursor cursor = contentResolver.query(uri, null, null, null, null);            if (cursor.moveToFirst()) {                @SuppressLint("Range")                String displayName = cursor.getString(cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME));                try {                    InputStream is = contentResolver.openInputStream(uri);                    File cache = new File(context.getExternalCacheDir().getAbsolutePath(), Math.round((Math.random() + 1) * 1000) + displayName);                    FileOutputStream fos = new FileOutputStream(cache);                    FileUtils.copy(is, fos);                    file = cache;                    fos.close();                    is.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return file == null ? null : file.getAbsolutePath();    }}